# enum, const enum, as const
- 프로젝트에서 상수 관리를 하기 위한 방법으로 enum, const enum, as const 방식을 사용한다. 각 방법이 정확히 어떤 특징을 가지고 있고 개인적으로 어떤 방법이 적합할지 정리해봤다.

## enum
### 특징
- 명명된 상수의 그룹화: enum은 관련된 상수 값들을 함께 그룹화하여 관리할 수 있다.
- 자동 값 할당: enum 멤버에 값을 명시적으로 할당하지 않을 시, 자동으로 숫자 값을 할당 받는다. 첫 멤버의 값은 0, 이후 멤버는 1씩 증가한다.
- 역매핑: 숫자 기반의 enum은 값에서 이름으로, 이름에서 값으로의 양방향 매핑이 자동으로 생성된다.
### 장점
- 코드의 안정성: enum을 사용하면 타입 안전성이 보장되며, 오류 가능성이 줄어든다.
- 자동완성과 가독성: enum은 코드의 자동완성을 지원하며, 코드의 의도를 명확하게 전달할 수 있어서 가독성이 향상된다.
### 단점
- 번들 크기 증가: enum은 타입스크립트에서만 사용이 가능하므로 컴파일 시 자바스크립트 코드에 추가적인 구조를 생성한다. (양방향 매핑 특징 때문.)
- 런타임 오버헤드: enum은 런타임에 객체로 존재하므로 메모리 사용량이 늘어날 수 있으며 불필요한 런타임 비용이 발생할 수 있다.
### 코드 예시
```tsx
enum Color {
    Red = 1, // 1
    Green, // 2
    Blue // 3
}

let c: Color = Color.Green;

console.log(c); // 2
console.log(Color[c]); // 'Green' - 역매핑을 통해 값에서 이름을 얻음
```
위의 타입스크립트 코드가 자바스크립트로 컴파일되면
```jsx
var Color;
(function (Color) {
    Color[Color["Red"] = 1] = "Red";
    Color[Color["Green"] = 2] = "Green";
    Color[Color["Blue"] = 3] = "Blue";
})(Color || (Color = {}));
```
이런식으로 번들 크기 증가의 원인이 될 수 있다.

## const enum
### 특징
- 컴파일 타임 상수: const enum의 멤버들은 컴파일 시에 계산되고, 그 결과가 직접 코드에 삽입된다. 이는 런타임 객체를 생성하지 않기 때문에 메모리 사용과 초기 로드 시간을 줄인다.
- 인라인 값 대체: const enum 멤버들은 사용되는 곳에 직접적으로 값이 삽입되므로, 런타임에 enum 객체를 조회할 필요가 없다.
### 장점
- 성능 최적화: const enum은 런타임에 객체를 생성하지 않고, 멤버 값이 코드 내에서 직접 대체되므로 성능 최적화에 유리하다.
- 번들 크기 감소: 생성되는 자바스크립트 코드에서 enum 객체가 포함되지 않기 때문에 최종 번들의 크기가 줄어든다.
### 단점
- 유연성 제한: const enum은 런타임에 접근할 수 없으므로, enum의 키와 값을 런타임에서 동적으로 사용할 수 없다.
- 디버깅 어려움: 컴파일 타임에 값이 대체되기 때문에, 디버깅 시 원래 enum 멤버의 이름을 추적하기 어렵다.
### 코드 예시
```tsx
const enum Color {
    Red = 3,
    Green = 5,
    Blue = 8
}

let myColor = Color.Red;
console.log(myColor); // 이 코드는 컴파일 후 'console.log(3);' 로 변환됩니다.
```

## as const
### 특징
- 리터럴 타입 강제: as const를 사용하면 변수의 타입이 해당 리터럴 값으로 좁혀진다. 예시로, let x = 10 as const;에서 변수 x는 10이라는 리터럴 값으로 타입이 결정된다.
- 불변성 강화: 객체나 배열에 사용될 경우, 모든 요소가 읽기 전용으로 설정된다. 이는 객체나 배열이 변경되지 않도록 강제한다.
- 타입 추론의 정확성 향상: as const를 사용하면 타입스크립트 컴파일러는 더 정확하고 구체적인 타입 정보를 추론할 수 있다.
### 장점
- 타입 안정성 향상: 코드에서 예상치 못한 변경을 방지하고, 불변 데이터 패턴을 강제하여 버그 발생 확률을 줄일 수 있다.
- 명확한 의도 표현: 개발자의 의도가 코드를 통해 명확하게 표현되므로, 유지보수가 용이해진다.
- 리터럴 타입과 함께 사용할 때의 이점: enum을 사용하지 않고도, 유사한 효과를 얻을 수 있어 코드의 양을 줄일 수 있다.
### 단점
- 유연성 제한: 코드의 일부가 변경될 필요가 있는 경우, as const 사용으로 인해 추가적인 수정이 요구될 수 있다.
- 과도한 사용: 모든 곳에 as const를 사용하면, 때로는 필요 이상으로 코드의 유연성을 제한할 수 있으며, 불필요한 복잡성을 추가할 수 있다.
### 코드 예시
```tsx
const config = {
  version: 1,
  name: "App",
  properties: {
    theme: "dark"
  }
} as const;

// config.version = 2; // 에러: Cannot assign to 'version' because it is a read-only property.
console.log(config.version); // 1

// config.properties.theme = "light"; // 에러: Cannot assign to 'theme' because it is a read-only property.
console.log(config.properties.theme); // "dark"
```

## 개인적으로 상수를 관리할 때 뭘 써야하는지에 대한 생각
- 본인은 as const로 상수를 관리하는 것이 가장 적합하다고 생각한다. 이에는 몇가지 이유가 있다.
  - enum은 tree-shaking이 안되고 컴파일 시 자바스크립트 객체로 변형되기 때문에 추가 번들링이 된다. (양방향 매핑 때문에 메모리를 차지하게 된다)
  - enum의 양방향 매핑 방식을 프로젝트에서 많이 사용하게 될지 의문이다.
  - enum은 원본 데이터 변형이 가능하다. (상수를 관리하려고 하는데 원본 데이터가 변형이 되면 상수로 관리하려는 의도에 맞을까 의문이다)
  - const enum은 enum과 달리 추가적으로 메모리를 차지하지 않지만, 컴파일시 인라인 코드로 변형되기 때문에 런타임에 원래 멤버로 접근이 불가능하다. (런타임 에러 발생 시 디버깅 어려워짐)
  - as const는 원본 데이터 변형이 불가능하고 컴파일 이후에도 JavaScript 객체로 남이있기에 런타임 시 동적으로 멤버 접근이 가능하다.
