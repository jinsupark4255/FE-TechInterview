# 클로져

## 스코프 (변수에 접근할 수 있는 범위)

### 스코프에는 '전역 스코프'와 '지역 스코프'가 존재한다.

```
전역 스코프 = 전역에 선언되어 있어서 어느 곳에서든지 해당 변수에 접근 가능
지역 스코프 = 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에서는 접근 불가능
```

### 코드로 더 자세히 알아보자.

```js
const a = 10; // 전역 스코프
function example() {
  // 지역 스코프
  const a = 20;
  console.log(a);
}
exmple(); // 20
console.log(a); // 10
```

### 코드 동작 순서

1. example 함수에서 a를 출력하기 위해 자신의 함수 스코프 안에 변수 a가 있는지 찾아본다.
2. example() 호출이 끝나면 example 함수는 실행 컨텍스트에서 pop 된다.
3. 이후 a를 다시 출력하면 전역 스코프 안에 변수 a를 출력하게 된다.

### 그렇다면 example 함수 안에 변수 a 선언을 지우면 console 출력이 될까?

```js
const a = 10; // 전역 스코프
function example() {
  // 지역 스코프
  console.log(a);
}
exmple(); // 10
```

### 에러가 안 나고 10이 출력된다.

- 이는 Scope Chaining 때문인데, exmple 함수 내에서 변수 a를 찾지 못하면 상위 스코프로 올라간다.
- 상위 스코프는 현재 전역 스코프이며, 전역 스코프에 변수 a가 선언되어 있으므로 10이 출력된다.
- 만약 전역 스코프에도 변수 a가 선언이 되어있지 않는다면 에러가 발생할 것이다.

### 이제 함수 안에 함수를 선언해보자

```js
const a = 10;
function example() {
  const a = 20;
  const inner = function () {
    console.log(a);
  };
  return inner;
}
const result = example();
result();
```

- 해당 코드의 실행 결과는 20이다.
- 이유를 설명하기 전, 동적 스코프와 정적 스코프에 대해 알아보자.

### 상위 스코프가 결정되는 시점을 기준으로 동적 스코프와 정적 스코프로 나뉜다.

```
동적 스코프 : 함수가 호출되는 시점에 결정되는 것
정적 스코프 : 함수가 정의되는 시점에 결정되는 것 (===렉시컬 스코프)
```

- 자바스크립트는 렉시컬 스코프를 따르기 때문에 함수가 정의되자마자 상위 스코프가 결정이 된다.
- 이후에 해당 함수에 의해 함수 객체가 생성이 되면 해당 함수 객체는 본인의 상위 스코프를 알게 된다.

### 이제 결과가 20이 나온 이유를 동작 순서로 설명해보자

1. example 함수는 inner를 result에 반환하며 생명주기를 마감한다. (실행 컨텍스트에서 pop)
2. result를 호출하게 되면 inner 함수 내에서 a를 출력한다.
3. 하지만, inner 함수 내에서는 a 변수가 선언되어 있지 않다.
4. 여기서 inner 함수의 상위 스코프인 exmple 함수에 정의되어 있는 변수 a의 값인 20을 가져온다.
5. 따라서 20이 출력이 된다.

### 근데, example 함수가 실행 컨텍스트에서 pop 됐으면 변수 a에 접근이 안되는거 아닌가?

- 중첩함수 inner가 이미 생명주기를 마감한 example 함수의 지역 변수 a를 참조할 수 있다면 inner 함수를 '클로져'라고 한다.
- inner 함수 객체는 본인의 내부 슬롯에 저장된 상위 스코프에 의존하여 example 함수의 렉스컬 환경을 참조하기 때문에 가비지 컬렉션의 대상이 되지 않는다.
- 즉, 실행 컨택스트 스택에서 example 함수가 제거 되지만, outer 함수의 렉시컬 환경까지 소멸되지는 않으므로 변수 a를 다시 참조할 수 있는 것이다.

## 결론

클로져는 하나의 state가 의도치 않게 변동되지 않도록 안전하게 은닉하고, 특정 함수에게만 state 변경을 허용하기 위해 사용한다.
